def subset(nums):
    result = []        
    
    def backtrak(start,temp):
       
        result.append(temp[:])
        for i in range(start,len(nums)):
            temp.append(nums[i])
            backtrak(i+1,temp)
            temp.pop()
            
    backtrak (0,[])        
    return result

user = input("Enter a number sperated by the comma : " )

nums = list(map(int,user.split(',')))

subsets = subset(nums)
print("list of all subset")
print(subsets)


"""Code Explanation:
Function subset(nums):

This function generates all possible subsets of the list nums using a backtracking approach.
Variables and Helper Function:

result: This list will store all the subsets.
backtrak(start, temp): This is the recursive helper function that generates the subsets.
Step-by-Step Breakdown:
1. subset(nums) function:
This function is the main function that is called when you want to generate subsets from the list nums. It initializes the result list, which will hold all the subsets, and then calls the backtrak() function to start the process.

2. backtrak(start, temp) function:
Parameters:
start: The index from which to start the process of choosing numbers.
temp: A list that holds the current subset being built.
What happens inside the backtrak() function:
result.append(temp[:]): Every time the function is called, it adds the current subset (temp) to the result list. temp[:] creates a copy of the temp list, so that changes to temp in the future don't affect previously added subsets.

for i in range(start, len(nums)):: This loop iterates over the elements of the list nums starting from the index start. This ensures we only add numbers that come after the current index (this helps avoid duplicates and ensures every combination is unique).

temp.append(nums[i]): This adds the current element nums[i] to the temp list, building the current subset.

backtrak(i + 1, temp): This is the recursive call. After adding an element to temp, it moves on to the next index (i + 1), effectively choosing the next element to be added to the subset.

temp.pop(): This line removes the last element added to temp to "backtrack" and try other possibilities (this is how backtracking works). After exploring one branch of possibilities, it removes the last element and tries the next one.

3. User Input:
user = input("Enter a number separated by the comma : "): The user is prompted to input numbers separated by commas. The input is a single string, for example: "1,2,3".

nums = list(map(int, user.split(','))): The split(',') method splits the input string into a list of strings. map(int, ...) converts each string to an integer, and list() creates a list of integers. For example, "1,2,3" becomes [1, 2, 3].

4. Generating the Subsets:
subsets = subset(nums): The subset() function is called with the list of numbers nums. This function returns the list of all subsets, which is stored in the subsets variable.
5. Output:
print("list of all subset"): This prints a message indicating that all subsets are being displayed.
print(subsets): This prints the list of all subsets generated by the backtracking function.
Example:
Let's say the user inputs:

csharp
Copy
Enter a number separated by the comma: 1,2,3
The function subset([1, 2, 3]) is called.
The backtracking function starts generating subsets:
The first subset generated is the empty subset [].
Then, it adds 1 to create [1].
It then adds 2 to create [1, 2].
It adds 3 to create [1, 2, 3].
It backtracks and removes 3 to try the subset [1, 3].
It then goes back to trying just [2] and [2, 3], and finally [3].
Final Output:
For the input 1,2,3, the output will be:

css
Copy
list of all subset
[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]
Each subset corresponds to a combination of numbers from the input list [1, 2, 3]. The order in which the subsets appear is determined by the backtracking process, which ensures all subsets are generated.

Summary:
This code uses backtracking to generate all subsets.
The recursion explores each possibility by either including or excluding each element.
It then stores the current subset in result and "backtracks" to try other combinations.


"""